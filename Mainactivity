package com.example.isopod

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.background
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.AssistChip
import androidx.compose.material3.AssistChipDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Checkbox
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SmallTopAppBar
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewmodel.compose.viewModel
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import java.util.Locale

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            TaskPlannerTheme {
                val viewModel: TaskViewModel = viewModel()
                TaskPlannerScreen(viewModel = viewModel)
            }
        }
    }
}

data class Task(
    val id: Long,
    val title: String,
    val description: String,
    val dueDate: LocalDate?,
    val priority: TaskPriority,
    val isCompleted: Boolean
)

enum class TaskPriority(val displayName: String, val color: Color) {
    HIGH("High", Color(0xFFD32F2F)),
    MEDIUM("Medium", Color(0xFFFBC02D)),
    LOW("Low", Color(0xFF388E3C));
}

enum class TaskFilter(val label: String) {
    ALL("All"),
    ACTIVE("Active"),
    COMPLETED("Completed")
}

class TaskRepository {
    private val formatter = DateTimeFormatter.ofPattern("MMM d", Locale.getDefault())
    private val tasks = mutableListOf(
        Task(
            id = 1L,
            title = "Finalize project proposal",
            description = "Consolidate stakeholder feedback and prepare the final draft.",
            dueDate = LocalDate.now().plusDays(2),
            priority = TaskPriority.HIGH,
            isCompleted = false
        ),
        Task(
            id = 2L,
            title = "Design review",
            description = "Review the wireframes for the new onboarding flow.",
            dueDate = LocalDate.now().plusDays(5),
            priority = TaskPriority.MEDIUM,
            isCompleted = false
        ),
        Task(
            id = 3L,
            title = "Sprint retrospective",
            description = "Gather insights from the team and document action items.",
            dueDate = LocalDate.now().minusDays(1),
            priority = TaskPriority.LOW,
            isCompleted = true
        )
    )

    fun getTasks(): List<Task> = tasks.sortedWith(compareBy<Task> {
        it.isCompleted
    }.thenBy { it.dueDate ?: LocalDate.MAX })

    fun addTask(title: String, description: String, dueDate: LocalDate?, priority: TaskPriority) {
        val sanitizedTitle = title.trim()
        if (sanitizedTitle.isEmpty()) return
        val newTask = Task(
            id = System.currentTimeMillis(),
            title = sanitizedTitle,
            description = description.trim(),
            dueDate = dueDate,
            priority = priority,
            isCompleted = false
        )
        tasks.add(newTask)
    }

    fun toggleTaskCompletion(id: Long) {
        tasks.replaceAll { task ->
            if (task.id == id) task.copy(isCompleted = !task.isCompleted) else task
        }
    }

    fun deleteTask(id: Long) {
        tasks.removeAll { it.id == id }
    }

    fun formatDueDate(date: LocalDate?): String = date?.let { formatter.format(it) } ?: "No due date"
}

data class TaskUiState(
    val tasks: List<Task> = emptyList(),
    val searchQuery: String = "",
    val filter: TaskFilter = TaskFilter.ALL,
    val sortDescending: Boolean = false
) {
    val filteredTasks: List<Task>
        get() {
            val base = tasks.filter { task ->
                val matchesFilter = when (filter) {
                    TaskFilter.ALL -> true
                    TaskFilter.ACTIVE -> !task.isCompleted
                    TaskFilter.COMPLETED -> task.isCompleted
                }
                val matchesQuery = searchQuery.isBlank() ||
                        task.title.contains(searchQuery, ignoreCase = true) ||
                        task.description.contains(searchQuery, ignoreCase = true)
                matchesFilter && matchesQuery
            }
            val comparator = if (sortDescending) {
                compareByDescending<Task> { it.isCompleted }
                    .thenByDescending { it.dueDate ?: LocalDate.MIN }
            } else {
                compareBy<Task> { it.isCompleted }
                    .thenBy { it.dueDate ?: LocalDate.MAX }
            }
            return base.sortedWith(comparator)
        }
}

class TaskViewModel : ViewModel() {
    private val repository = TaskRepository()
    var uiState by mutableStateOf(TaskUiState(tasks = repository.getTasks()))
        private set

    fun updateSearchQuery(query: String) {
        refreshState { it.copy(searchQuery = query) }
    }

    fun updateFilter(filter: TaskFilter) {
        refreshState { it.copy(filter = filter) }
    }

    fun toggleSortOrder() {
        refreshState { it.copy(sortDescending = !it.sortDescending) }
    }

    fun addTask(title: String, description: String, dueDate: LocalDate?, priority: TaskPriority) {
        repository.addTask(title, description, dueDate, priority)
        refreshState()
    }

    fun toggleCompletion(id: Long) {
        repository.toggleTaskCompletion(id)
        refreshState()
    }

    fun deleteTask(id: Long) {
        repository.deleteTask(id)
        refreshState()
    }

    fun formatDueDate(date: LocalDate?): String = repository.formatDueDate(date)

    private fun refreshState(transform: (TaskUiState) -> TaskUiState = { it }) {
        uiState = transform(uiState.copy(tasks = repository.getTasks()))
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TaskPlannerScreen(viewModel: TaskViewModel) {
    val state = viewModel.uiState
    var showDialog by remember { mutableStateOf(false) }
    Scaffold(
        topBar = {
            SmallTopAppBar(
                title = { Text(text = "Task Planner") },
                actions = {
                    IconButton(onClick = { viewModel.toggleSortOrder() }) {
                        Icon(imageVector = Icons.Default.FilterList, contentDescription = "Sort tasks")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { showDialog = true }) {
                Icon(imageVector = Icons.Default.Add, contentDescription = "Add task")
            }
        }
    ) { paddingValues ->
        Surface(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
                TaskSearchField(
                    query = state.searchQuery,
                    onQueryChange = viewModel::updateSearchQuery
                )
                Spacer(modifier = Modifier.height(12.dp))
                FilterChips(
                    activeFilter = state.filter,
                    onFilterSelected = viewModel::updateFilter
                )
                Spacer(modifier = Modifier.height(16.dp))
                if (state.filteredTasks.isEmpty()) {
                    EmptyTasksPlaceholder()
                } else {
                    TaskList(
                        tasks = state.filteredTasks,
                        onToggle = viewModel::toggleCompletion,
                        onDelete = viewModel::deleteTask,
                        dueDateFormatter = viewModel::formatDueDate
                    )
                }
            }
        }
    }

    if (showDialog) {
        TaskCreationDialog(
            onDismiss = { showDialog = false },
            onCreate = { title, description, dueDate, priority ->
                viewModel.addTask(title, description, dueDate, priority)
                showDialog = false
            }
        )
    }
}

@Composable
fun TaskSearchField(query: String, onQueryChange: (String) -> Unit) {
    OutlinedTextField(
        modifier = Modifier.fillMaxWidth(),
        value = query,
        onValueChange = onQueryChange,
        label = { Text(text = "Search tasks") },
        singleLine = true
    )
}

@Composable
fun FilterChips(activeFilter: TaskFilter, onFilterSelected: (TaskFilter) -> Unit) {
    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
        TaskFilter.values().forEach { filter ->
            AssistChip(
                onClick = { onFilterSelected(filter) },
                label = { Text(text = filter.label) },
                colors = AssistChipDefaults.assistChipColors(
                    containerColor = if (filter == activeFilter) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surface,
                    labelColor = if (filter == activeFilter) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface
                )
            )
        }
    }
}

@Composable
fun TaskList(
    tasks: List<Task>,
    onToggle: (Long) -> Unit,
    onDelete: (Long) -> Unit,
    dueDateFormatter: (LocalDate?) -> String
) {
    LazyColumn(verticalArrangement = Arrangement.spacedBy(12.dp)) {
        items(tasks, key = { it.id }) { task ->
            TaskItem(
                task = task,
                onToggle = onToggle,
                onDelete = onDelete,
                dueDateFormatter = dueDateFormatter
            )
        }
    }
}

@Composable
fun TaskItem(
    task: Task,
    onToggle: (Long) -> Unit,
    onDelete: (Long) -> Unit,
    dueDateFormatter: (LocalDate?) -> String
) {
    Card(
        shape = RoundedCornerShape(20.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(
            containerColor = if (task.isCompleted) MaterialTheme.colorScheme.surfaceVariant else MaterialTheme.colorScheme.surface
        )
    ) {
        Column(modifier = Modifier.fillMaxWidth().padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Checkbox(
                    checked = task.isCompleted,
                    onCheckedChange = { onToggle(task.id) }
                )
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = task.title,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold),
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                    if (task.description.isNotBlank()) {
                        Text(
                            text = task.description,
                            style = MaterialTheme.typography.bodyMedium,
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
                IconButton(onClick = { onDelete(task.id) }) {
                    Icon(imageVector = Icons.Default.Delete, contentDescription = "Delete task")
                }
            }
            Spacer(modifier = Modifier.height(8.dp))
            Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                PriorityIndicator(priority = task.priority)
                Divider(
                    modifier = Modifier
                        .height(16.dp)
                        .width(1.dp)
                        .background(MaterialTheme.colorScheme.outlineVariant)
                )
                Icon(imageVector = Icons.Default.Check, contentDescription = null, tint = MaterialTheme.colorScheme.primary, modifier = Modifier.size(18.dp))
                Text(
                    text = if (task.isCompleted) "Completed" else "Pending",
                    style = MaterialTheme.typography.labelLarge,
                    color = if (task.isCompleted) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.secondary
                )
                Spacer(modifier = Modifier.weight(1f))
                Text(
                    text = dueDateFormatter(task.dueDate),
                    style = MaterialTheme.typography.labelLarge,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}

@Composable
fun PriorityIndicator(priority: TaskPriority) {
    Row(verticalAlignment = Alignment.CenterVertically) {
        Box(
            modifier = Modifier
                .size(12.dp)
                .background(priority.color, CircleShape)
        )
        Spacer(modifier = Modifier.width(6.dp))
        Text(text = priority.displayName, style = MaterialTheme.typography.labelLarge)
    }
}

@Composable
fun EmptyTasksPlaceholder() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(top = 64.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text(
            text = "No tasks yet",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Medium
        )
        Text(
            text = "Use the + button to add your first task.",
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

@Composable
fun TaskCreationDialog(
    onDismiss: () -> Unit,
    onCreate: (title: String, description: String, dueDate: LocalDate?, priority: TaskPriority) -> Unit
) {
    var title by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var dueDateText by remember { mutableStateOf("") }
    var selectedPriority by remember { mutableStateOf(TaskPriority.MEDIUM) }
    var showError by remember { mutableStateOf(false) }
    var dueDateError by remember { mutableStateOf<String?>(null) }

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = {
                    if (title.isBlank()) {
                        showError = true
                        dueDateError = null
                    } else {
                        val parsedDate = parseDate(dueDateText)
                        if (dueDateText.isNotBlank() && parsedDate == null) {
                            dueDateError = "Enter the date as yyyy-mm-dd"
                        } else {
                            dueDateError = null
                            onCreate(title, description, parsedDate, selectedPriority)
                        }
                    }
                }
            ) {
                Text(text = "Create")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(text = "Cancel")
            }
        },
        title = { Text(text = "New task") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                OutlinedTextField(
                    value = title,
                    onValueChange = {
                        title = it
                        if (it.isNotBlank()) showError = false
                    },
                    label = { Text(text = "Title") },
                    singleLine = true,
                    isError = showError && title.isBlank(),
                    supportingText = {
                        if (showError && title.isBlank()) {
                            Text(text = "Title cannot be empty", color = MaterialTheme.colorScheme.error)
                        }
                    }
                )
                OutlinedTextField(
                    value = description,
                    onValueChange = { description = it },
                    label = { Text(text = "Description") }
                )
                OutlinedTextField(
                    value = dueDateText,
                    onValueChange = {
                        dueDateText = it
                        if (dueDateError != null) {
                            dueDateError = null
                        }
                    },
                    label = { Text(text = "Due date (yyyy-mm-dd)") },
                    placeholder = { Text(text = LocalDate.now().toString()) },
                    isError = dueDateError != null,
                    supportingText = {
                        dueDateError?.let { message ->
                            Text(text = message, color = MaterialTheme.colorScheme.error)
                        }
                    }
                )
                PrioritySelector(
                    selected = selectedPriority,
                    onSelected = { selectedPriority = it }
                )
            }
        }
    )
}

private fun parseDate(input: String): LocalDate? {
    val trimmed = input.trim()
    if (trimmed.isEmpty()) return null
    return try {
        LocalDate.parse(trimmed)
    } catch (_: DateTimeParseException) {
        null
    }
}

@Composable
fun PrioritySelector(selected: TaskPriority, onSelected: (TaskPriority) -> Unit) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(text = "Priority", style = MaterialTheme.typography.labelLarge)
        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            TaskPriority.values().forEach { priority ->
                AssistChip(
                    onClick = { onSelected(priority) },
                    label = { Text(text = priority.displayName) },
                    colors = AssistChipDefaults.assistChipColors(
                        containerColor = if (priority == selected) priority.color.copy(alpha = 0.2f) else MaterialTheme.colorScheme.surface,
                        labelColor = if (priority == selected) priority.color else MaterialTheme.colorScheme.onSurface
                    )
                )
            }
        }
    }
}

private val LightColors = lightColorScheme(
    primary = Color(0xFF006874),
    onPrimary = Color.White,
    primaryContainer = Color(0xFF97F0FF),
    onPrimaryContainer = Color(0xFF001F24),
    secondary = Color(0xFF4A6267),
    onSecondary = Color.White,
    surface = Color(0xFFF6FEFF),
    surfaceVariant = Color(0xFFE0F2F1)
)

private val DarkColors = darkColorScheme(
    primary = Color(0xFF4FD8EB),
    onPrimary = Color(0xFF00363D),
    primaryContainer = Color(0xFF004F58),
    onPrimaryContainer = Color(0xFF97F0FF),
    secondary = Color(0xFFB1CBD0),
    onSecondary = Color(0xFF1C3438),
    surface = Color(0xFF101417),
    surfaceVariant = Color(0xFF273032)
)

@Composable
fun TaskPlannerTheme(
    useDarkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (useDarkTheme) DarkColors else LightColors
    MaterialTheme(
        colorScheme = colorScheme,
        typography = MaterialTheme.typography,
        content = content
    )
}

@Preview(showBackground = true)
@Composable
fun TaskPlannerPreview() {
    TaskPlannerTheme {
        val sampleViewModel = TaskViewModel()
        TaskPlannerScreen(viewModel = sampleViewModel)
    }
}
